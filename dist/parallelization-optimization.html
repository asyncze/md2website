<html lang='en'><head><link rel='icon' href='fav.png'><title>Parallelization Optimization</title><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'><meta name='author' content='Michael Sjöberg'><meta name='description' content='My projects, posts, and programming notes.'><meta name='theme-color' content='#161716'><meta name='application-name' content='Michael Sjöberg'><meta name='apple-mobile-web-app-title' content='Michael Sjöberg'><meta name='apple-mobile-web-app-capable' content='yes'><meta name='mobile-web-app-capable' content='yes'><meta name='apple-mobile-web-app-status-bar-style' content='#161716'><link rel='stylesheet' href='main.min.css'><script src='main.min.js'></script></head><body><nav><p><a href="index.html">home</a> <a href="projects.html">projects</a> <a href="posts.html">posts</a> <a href="programming.html">programming</a></p></nav><div class='page'><h1>Parallelization Optimization</h1>
<p><em>July 2023</em> <a href="programming.html#python">Python</a> <a href="programming.html#compilers">Compilers</a></p>
<p>Parallelization optimization is a form of optimization that aims to improve the performance of a program by parallelizing it, i.e. by splitting the program into smaller parts that can be executed simultaneously.</p>
<pre><code class="language-python">import multiprocessing as mp
import timeit

# timeit.template = &quot;&quot;&quot;
# def inner(_it, _timer{init}):
#     from tqdm import tqdm
#     {setup}
#     _t0 = _timer()
#     for _i in tqdm(_it, total=_it.__length_hint__()):
#         {stmt}
#     _t1 = _timer()
#     return _t1 - _t0
# &quot;&quot;&quot;

def sum_of_squares(numbers):
    return sum([num * num for num in numbers])

def sum_of_squares_parallel(numbers):
    # use all available cores
    num_processes = mp.cpu_count()
    chunk_size = len(numbers) // num_processes
    # create pool of processes
    pool = mp.Pool(processes=num_processes)
    # divide work into chunks
    chunks = [numbers[i:i + chunk_size] for i in range(0, len(numbers), chunk_size)]
    results = pool.map(sum_of_squares, chunks)
    # close
    pool.close()
    # combine results
    pool.join()

    return sum(results)

if __name__ == '__main__':
    assert sum_of_squares(list(range(1, 10000))) == sum_of_squares_parallel(list(range(1, 10000)))
    # timeit
    n = list(range(1, 10000000))
    print(f&quot;sum_of_squares: {timeit.timeit(lambda: sum_of_squares(n), number=10)}&quot;)
    # sum_of_squares: 7.48474136996083
    print(f&quot;sum_of_squares_parallel: {timeit.timeit(lambda: sum_of_squares_parallel(n), number=10)}&quot;)
    # sum_of_squares_parallel: 6.641842097043991
</code></pre></div><div id='footer'><p>[<a id='invert'>light|dark</a>] [<a href='https://github.com/mixmaester/html_builder'>source</a>]</p><p><span class='small'>DOM loaded in <span id='dom_time'></span>, page loaded in <span id='load_time'></span></span></p></div></body></html>